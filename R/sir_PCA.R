# Hello world function

#' Day hello
#'
#' @description
#' This function says hello
#'
#' @param none no arguments
#'
#' @return prints hello world
#'
#' @examples
#' hello()
#'
#' @export
sir_PCA <- function(sliced_data,
                    directions,
                    W = diag(nrow(sliced_data)),
                    varThreshold = 0.99) {

  ## sir_PCA

  ### inputs:
  # sliced_data: output of slicer function. Dataframe of column-slice means.
  # directions: integer, number of directions we want in our final low-dimensional Z.
  # W: matrix of slice weights. For weighted SIR with spatial response, it will be generated by this point by cells_weight_matrix function.

  ### output: matrix of eigenvectors of (X^H)^t %*% W %*% (X^H) where X^H is matrix of scaled slice means


  sliced_data_centered <- scale(sliced_data, center = TRUE, scale = FALSE)
  nslices <- nrow(sliced_data)
  m <- (t(as.matrix(sliced_data_centered)) %*% W %*% sliced_data_centered)/(nslices-1)
  eig_m <- eigen(m)
  all_pc <- eig_m$vectors
  eig_m_values <- eig_m$values
  propvariance_explained <- cumsum(eig_m_values)/sum(eig_m_values)
  d <- which(propvariance_explained > varThreshold)[1]
  # d <- min(ncol(all_pc), directions)
  d <- min(d, directions) # directions is a maximum number of directions
  return(list(all_pc[,1:d],
              d = d,
              evalues = eig_m$values))
}
