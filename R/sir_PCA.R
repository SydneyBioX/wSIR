# Hello world function

#' Day hello
#'
#' @description
#' This function says hello
#'
#' @param sliced_data no arguments
#' @param directions to fill
#' @param W to fill
#' @param varThreshold to fill
#'
#' @return prints hello world
#'
#' @examples
#' #hello()
#'
#' @export
sir_PCA <- function(sliced_data,
                    directions,
                    W = diag(nrow(sliced_data)),
                    varThreshold = 0.99) {

  ## sir_PCA

  ### inputs:
  # sliced_data: output of slicer function. Dataframe of column-slice means.
  # directions: integer, number of directions we want in our final low-dimensional Z.
  # W: matrix of slice weights. For weighted SIR with spatial response, it will be generated by this point by cells_weight_matrix function.

  ### output: matrix of eigenvectors of (X^H)^t %*% W %*% (X^H) where X^H is matrix of scaled slice means
  nslices <- nrow(sliced_data)
  sliced_data <- as.matrix(sliced_data)
  m <- (t(as.matrix(sliced_data)) %*% W %*% sliced_data)
  eig_m <- eigen(m)
  all_pc <- eig_m$vectors
  eig_m_values <- eig_m$values
  propvariance_explained <- cumsum(eig_m_values)/sum(eig_m_values)
  d <- which(propvariance_explained > varThreshold)[1]
  d <- min(d, directions) # directions is a maximum number of directions
  return(list(evectors = all_pc[,1:d],
              d = d,
              evalues = eig_m$values))
}
